/**
 * @file   float.cpp
 * @author Dennis Sitelew 
 * @date   Apr 03, 2024
 *
 * Ensure floating-point values (half, single and double) can be encoded.
 */

#include <catch2/catch_test_macros.hpp>

#include <test/encoding.h>

using namespace test;

TEST_CASE("Floating Point", "[encoding]") {
   check_encoding(0.0f, {0xF9, 0x00, 0x00});
   check_encoding(0.0, {0xF9, 0x00, 0x00});

   check_encoding(-0.0f, {0xF9, 0x80, 0x00});
   check_encoding(-0.0, {0xF9, 0x80, 0x00});

   check_encoding(1.0f, {0xF9, 0x3C, 0x00});
   check_encoding(1.0, {0xF9, 0x3C, 0x00});

   check_encoding(1.1f, {0xFA, 0x3F, 0x8C, 0xCC, 0xCD});
   check_encoding(1.1, {0xFB, 0x3F, 0xF1, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9A});

   check_encoding(1.5f, {0xF9, 0x3E, 0x00});
   check_encoding(1.5, {0xF9, 0x3E, 0x00});

   check_encoding(65504.0f, {0xF9, 0x7B, 0xFF});
   check_encoding(65504.0, {0xF9, 0x7B, 0xFF});

   check_encoding(100000.0f, {0xFA, 0x47, 0xC3, 0x50, 0x00});
   check_encoding(100000.0, {0xFA, 0x47, 0xC3, 0x50, 0x00});

   check_encoding(3.4028234663852886e+38f, {0xFA, 0x7F, 0x7F, 0xFF, 0xFF});
   check_encoding(3.4028234663852886e+38, {0xFA, 0x7F, 0x7F, 0xFF, 0xFF});

   // check_encoding(1.0e+300f, {0xFB, 0x7E, 0x37, 0xE4, 0x3C, 0x88, 0x00, 0x75, 0x9C}); // not representable with float
   check_encoding(1.0e+300, {0xFB, 0x7E, 0x37, 0xE4, 0x3C, 0x88, 0x00, 0x75, 0x9C});

   check_encoding(5.960464477539063e-8f, {0xF9, 0x00, 0x01});
   check_encoding(5.960464477539063e-8, {0xF9, 0x00, 0x01});

   check_encoding(0.00006103515625f, {0xF9, 0x04, 0x00});
   check_encoding(0.00006103515625, {0xF9, 0x04, 0x00});

   check_encoding(-4.0f, {0xF9, 0xC4, 0x00});
   check_encoding(-4.0, {0xF9, 0xC4, 0x00});

   check_encoding(-4.1f, {0xFA, 0xC0, 0x83, 0x33, 0x33});
   check_encoding(-4.1, {0xFB, 0xC0, 0x10, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66});

   check_encoding(std::numeric_limits<float>::infinity(), {0xF9, 0x7C, 0x00});
   check_encoding(std::numeric_limits<float>::quiet_NaN(), {0xF9, 0x7E, 0x00});
   check_encoding(-std::numeric_limits<float>::infinity(), {0xF9, 0xFC, 0x00});

   check_encoding(std::numeric_limits<double>::infinity(), {0xF9, 0x7C, 0x00});
   check_encoding(std::numeric_limits<double>::quiet_NaN(), {0xF9, 0x7E, 0x00});
   check_encoding(-std::numeric_limits<double>::infinity(), {0xF9, 0xFC, 0x00});
}
